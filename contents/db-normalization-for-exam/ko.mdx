import ProblemAnswer from "@/app/components/ProblemAnswer";
import ImageWithCaption from "@/app/components/ImageWithCaption";
import Details from "@/app/components/Details";

export const metadata = {
  title:
    "🗃️ 데이터베이스 정규화, 함수 종속성, 반정규화| 🚀정처기 실기 대비 문제 포함",
  description:
    "정보처리기사 시험의 핵심 개념인 데이터베이스 정규화(Normalization)의 모든 것을 알아봅니다. 1NF부터 5NF까지 각 정규형의 개념과 조건, 함수 종속성, 그리고 반정규화의 개념까지 예제와 함께 쉽게 설명하고 실기 대비 문제로 마무리합니다.",
  publishedAt: "2025-07-12",
  lastModifiedAt: "2025-07-12",
  timeToRead: 0,
  tags: ["정처기", "데이터베이스", "DB", "정규화", "Normalization", "반정규화"],
  heroImage: "/contents/default.jpg",
};

> 💡 **정규화(Normalization)** 는 정처기 실기 단골 문제 중 하나 입니다. 이 포스트 하나로 완벽하게 정리해 보세요. 각 정규형의 핵심 개념과 예시, 그리고 마지막 실전 문제까지 꼼꼼하게 학습하면 합격에 한 걸음 더 다가갈 수 있습니다.

## 📈 데이터베이스 정규화란?

**정규화(Normalization)** 는 관계형 데이터베이스에서 데이터의 중복을 최소화하고, 데이터 무결성을 보장하기 위해 테이블 구조를 체계적으로 분해하는 과정입니다. 정규화를 통해 이상 현상(Anomaly)을 방지하고, 데이터 구조의 안정성과 유지보수성을 향상시킬 수 있습니다.

- **이상 현상(Anomaly)**: 데이터 중복으로 인해 발생할 수 있는 문제들입니다.
  - **삽입 이상(Insertion Anomaly)**: 불필요한 데이터 없이는 원하는 데이터를 삽입할 수 없는 현상.
  - **삭제 이상(Deletion Anomaly)**: 특정 정보를 삭제하면, 원치 않는 다른 정보까지 함께 삭제되는 현상.
  - **갱신 이상(Update Anomaly)**: 중복된 데이터 중 일부만 수정되어 데이터 불일치가 발생하는 현상.

---

## 🔑 함수 종속성(Functional Dependency)

정규화를 이해하기 위해선 **함수 종속성** 개념을 먼저 알아야 합니다.

어떤 릴레이션에서 속성 A의 값이 속성 B의 값을 유일하게 결정할 때, "속성 B는 속성 A에 함수적으로 종속된다"고 말하며, `A → B`로 표기합니다. 여기서 A를 **결정자(Determinant)**, B를 **종속자(Dependent)**라고 합니다.

- **완전 함수 종속(Full Functional Dependency)**: 기본키 전체에 대해서만 종속되며, 기본키의 일부에는 종속되지 않는 경우입니다. (2정규형의 핵심)
- **부분 함수 종속(Partial Functional Dependency)**: 기본키의 일부 속성에 종속되는 경우입니다.
- **이행 함수 종속(Transitive Functional Dependency)**: `A → B`이고 `B → C`일 때, `A → C`가 성립하는 관계입니다. (3정규형의 핵심)

---

## 🔢 정규화 단계 요약

| 정규형                        | **핵심 조건**                                                             | **제거 대상**        |
| :---------------------------- | :------------------------------------------------------------------------ | :------------------- |
| **1NF (제1정규형)**           | 모든 속성 값은 **원자값(Atomic Value)** 이어야 한다.                      | 다중값 속성          |
| **2NF (제2정규형)**           | 1NF를 만족하고, **부분 함수 종속**을 제거해야 한다. (완전 함수 종속)      | 부분 함수 종속       |
| **3NF (제3정규형)**           | 2NF를 만족하고, **이행 함수 종속**을 제거해야 한다.                       | 이행 함수 종속       |
| **BCNF (보이스-코드 정규형)** | 3NF를 만족하고, 모든 **결정자가 후보키**여야 한다.                        | 후보키가 아닌 결정자 |
| **4NF (제4정규형)**           | BCNF를 만족하고, **다치 종속(Multi-valued Dependency)** 을 제거해야 한다. | 다치 종속            |
| **5NF (제5정규형)**           | 4NF를 만족하고, **조인 종속(Join Dependency)** 을 이용한다.               | 조인 종속            |

---

## 1️⃣ 제1정규형 (1NF)

**제1정규형**은 릴레이션의 모든 속성 값이 **원자값(Atomic Value)**으로만 구성되어야 한다는 규칙입니다. 즉, 하나의 속성 값에 여러 개의 값이 들어갈 수 없습니다.

- **예시**: 학생이 수강하는 과목을 저장할 때, `수강과목` 속성에 '자료구조, 알고리즘'과 같이 여러 값을 넣으면 1NF를 위반합니다.

**[정규화 전]**

| 학번 | 이름   | 수강과목           |
| :--- | :----- | :----------------- |
| 1001 | 김철수 | 자료구조, 알고리즘 |
| 1002 | 이영희 | 운영체제           |

**[1NF 정규화 후]**

| 학번 | 이름   | 수강과목 |
| :--- | :----- | :------- |
| 1001 | 김철수 | 자료구조 |
| 1001 | 김철수 | 알고리즘 |
| 1002 | 이영희 | 운영체제 |

---

## 2️⃣ 제2정규형 (2NF)

**제2정규형**은 릴레이션이 1NF를 만족하고, **부분 함수 종속(Partial Functional Dependency)**을 모두 제거한 상태여야 합니다. 즉, 모든 속성이 기본키 전체에 **완전 함수 종속**되어야 합니다. (기본키가 단일 속성이면 항상 2NF를 만족합니다.)

- **예시**: `(학번, 과목코드)`를 기본키로 사용하는 수강 릴레이션에서, `성적`은 `(학번, 과목코드)` 모두에 종속되지만, `교수명`은 `과목코드`에만 종속(부분 함수 종속)됩니다.

**[정규화 전] (기본키: 학번, 과목코드)**

| 학번 | 과목코드 | 교수명 | 성적 |
| :--- | :------- | :----- | :--- |
| 1001 | CS101    | 김교수 | A+   |
| 1001 | CS202    | 이교수 | A0   |
| 1002 | CS101    | 김교수 | B+   |

**[2NF 정규화 후]**

**[수강 테이블]**

| 학번 | 과목코드 | 성적 |
| :--- | :------- | :--- |
| 1001 | CS101    | A+   |
| 1001 | CS202    | A0   |
| 1002 | CS101    | B+   |

**[과목 테이블]**

| 과목코드 | 교수명 |
| :------- | :----- |
| CS101    | 김교수 |
| CS202    | 이교수 |

---

## 3️⃣ 제3정규형 (3NF)

**제3정규형**은 릴레이션이 2NF를 만족하고, **이행 함수 종속(Transitive Functional Dependency)** 을 모두 제거한 상태여야 합니다. 이행 함수 종속이란, `A → B`이고 `B → C`일 때 `A → C`가 성립하는 관계를 의미합니다.

- **예시**: `학번 → 학과코드` 이고 `학과코드 → 학과명` 이라면, `학번 → 학과명` 이라는 이행 함수 종속이 존재합니다.

**[정규화 전] (기본키: 학번)**

| 학번 | 이름   | 학과코드 | 학과명     |
| :--- | :----- | :------- | :--------- |
| 1001 | 김철수 | CS       | 컴퓨터과학 |
| 1002 | 이영희 | EE       | 전자공학   |
| 1003 | 박민준 | CS       | 컴퓨터과학 |

**[3NF 정규화 후]**

**[학생 테이블]**

| 학번 | 이름   | 학과코드 |
| :--- | :----- | :------- |
| 1001 | 김철수 | CS       |
| 1002 | 이영희 | EE       |
| 1003 | 박민준 | CS       |

**[학과 테이블]**

| 학과코드 | 학과명     |
| :------- | :--------- |
| CS       | 컴퓨터과학 |
| EE       | 전자공학   |

---

## BCNF (Boyce-Codd Normal Form)

**BCNF**는 3NF보다 강력한 정규형으로, 릴레이션의 **모든 결정자가 후보키(Candidate Key)여야 한다**는 규칙입니다. 3NF의 이상 현상을 대부분 해결하지만, 드물게 발생하는 특정 유형의 이상을 해결하기 위해 BCNF가 필요합니다.

<Details summary="후보키(Candidate Key)란?">
  **후보키(Candidate Key)**는 릴레이션(테이블)에서 각 튜플(행)을 유일하게 식별할 수 있는 **최소한의 속성(열)들의 집합**입니다.
  
  - **유일성(Uniqueness)**: 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 합니다.
  - **최소성(Minimality)**: 유일성을 만족하는 속성들 중 가장 적은 수의 속성으로 구성되어야 합니다. 즉, 키를 구성하는 어떤 속성을 제거하면 유일성이 깨져야 합니다.

하나의 릴레이션에는 여러 개의 후보키가 존재할 수 있으며, 이 중 하나를 선택하여 **기본키(Primary Key)**로 사용합니다. 나머지 후보키는 **대체키(Alternate Key)**라고 부릅니다.

</Details>

- **예시**: 피자 가게에서 각 피자에 들어가는 토핑과 그 토핑의 공급업체를 관리하는 상황을 가정해 보겠습니다.
  - **제약 조건**:
    1.  하나의 피자는 여러 종류의 토핑을 가질 수 있습니다.
    2.  하나의 토핑은 여러 피자에 사용될 수 있습니다.
    3.  **중요 규칙**: 각각의 `토핑(Topping)`은 **단 하나의 `공급업체(Supplier)`** 로부터만 공급받습니다. (예: '페퍼로니'는 항상 'A업체'에서, '올리브'는 항상 'B업체'에서 공급받음)
  - **함수 종속**: 위의 규칙 3번에 따라 `토핑 → 공급업체` 라는 함수 종속성이 성립합니다.
  - **BCNF 위반**: `토핑`은 `공급업체`를 결정하는 **결정자**입니다. 하지만 `토핑` 하나만으로는 테이블의 특정 행을 고유하게 식별할 수 없으므로 **후보키가 아닙니다.** (예: '페퍼로니'는 '슈프림 피자'에도, '미트러버 피자'에도 들어갈 수 있음) 모든 결정자가 후보키여야 한다는 BCNF 규칙을 위반합니다.

**[정규화 전]** (기본키: `{피자명, 토핑}`)

| 피자명          | 토핑     | 공급업체 |
| :-------------- | :------- | :------- |
| 슈프림 피자     | 페퍼로니 | A업체    |
| 슈프림 피자     | 올리브   | B업체    |
| 베지테리안 피자 | 올리브   | B업체    |
| 베지테리안 피자 | 버섯     | C업체    |
| 페퍼로니 피자   | 페퍼로니 | A업체    |

**[이상 현상 발생]**

- **갱신 이상**: 만약 '올리브'의 공급업체가 'B업체'에서 'D업체'로 바뀐다면, '올리브'가 포함된 모든 행을 찾아 수정해야 합니다. 하나라도 누락하면 데이터 불일치가 발생합니다.

**[BCNF 정규화 후]**

문제가 되는 함수 종속(`토핑 → 공급업체`)을 기준으로 테이블을 분해하여 BCNF를 만족시킵니다.

**[토핑-공급업체 테이블]**
토핑과 공급업체 간의 관계만을 저장하여 정보 중복을 제거합니다.

| 토핑     | 공급업체 |
| :------- | :------- |
| 페퍼로니 | A업체    |
| 올리브   | B업체    |
| 버섯     | C업체    |

**[피자-토핑 테이블]**
각 피자에 어떤 토핑이 들어가는지에 대한 정보만 저장합니다.

| 피자명          | 토핑     |
| :-------------- | :------- |
| 슈프림 피자     | 페퍼로니 |
| 슈프림 피자     | 올리브   |
| 베지테리안 피자 | 올리브   |
| 베지테리안 피자 | 버섯     |
| 페퍼로니 피자   | 페퍼로니 |

이렇게 분해하면 데이터 중복이 사라져 이상 현상을 해결할 수 있고, 각 테이블이 하나의 명확한 주제(토핑-공급업체, 피자-토핑)를 갖게 되어 구조가 더 안정적이고 관리하기 쉬워집니다.

---

## 4️⃣ 제4정규형 (4NF) & 5️⃣ 제5정규형 (5NF)

4NF와 5NF는 실무에서 거의 다루지 않지만, 개념은 알아두는 것이 좋습니다.

- **제4정규형 (4NF)**: **다치 종속(Multi-valued Dependency, MVD)** 을 제거한 정규형입니다. 1:N 관계에서 발생하는 종속성입니다.
- **제5정규형 (5NF)**: **조인 종속(Join Dependency, JD)** 을 이용하는 정규형으로, 모든 조인 종속이 후보키를 통해서만 성립되어야 합니다.

---

## 🔄 반정규화 (Denormalization)

**반정규화**는 정규화된 테이블 구조를 의도적으로 통합하거나 중복을 허용하여 **데이터베이스의 성능을 향상**시키는 과정입니다. 과도한 조인(JOIN)으로 인해 발생하는 성능 저하를 막기 위해 사용되지만, 데이터 일관성이 깨질 위험이 있으므로 신중하게 적용해야 합니다.

- **주요 기법**: 테이블 통합, 테이블 분할(수평/수직), 중복 속성 추가 등

---

## 📝 정처기 실기 대비 문제

<ProblemAnswer
  problem="릴레이션의 모든 속성 값이 원자값(Atomic Value)으로만 구성되도록 하는 정규형은 무엇인가?"
  correctAnswer="제1정규형 (1NF)"
/>

<ProblemAnswer
  problem="부분 함수 종속을 제거하고, 모든 속성이 기본키에 완전 함수 종속되도록 하는 정규형은 무엇인가?"
  correctAnswer="제2정규형 (2NF)"
/>

<ProblemAnswer
  problem="이행 함수 종속(Transitive Functional Dependency)을 제거하는 것을 목표로 하는 정규형은 무엇인가?"
  correctAnswer="제3정규형 (3NF)"
/>

<ProblemAnswer
  problem="릴레이션의 모든 결정자가 후보키(Candidate Key)가 되도록 하여, 3NF에서 발생하는 일부 이상 현상을 해결하는 정규형은 무엇인가?"
  correctAnswer="BCNF (보이스-코드 정규형)"
/>

<ProblemAnswer
  problem="데이터 중복을 최소화하고 무결성을 보장하기 위해 테이블 구조를 분해하는 과정을 무엇이라고 하는가?"
  correctAnswer="정규화 (Normalization)"
/>

<ProblemAnswer
  problem="정규화된 테이블에서 시스템 성능 향상을 위해 의도적으로 데이터 중복을 허용하거나 테이블을 통합하는 작업을 무엇이라고 하는가?"
  correctAnswer="반정규화 (Denormalization)"
/>

## ➡️ 다음 읽으면 좋은 포스팅

- [🗃️ 데이터베이스 무결성: 개체, 참조, 속성, 사용자, 키 | 🚀정처기 실기 대비 문제 포함](/ko/blog/data-integrity-for-exam)
- [정보처리기사 실기, 이론 문제 공략 팁 총정리📝](/ko/blog/korean-information-processing-engineer-practical-exam-strategy)
